{"ast":null,"code":"import { jsx as _jsx } from \"react/jsx-runtime\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport React, { useEffect, useState } from 'react';\nimport { throttle } from \"lodash\";\nexport const CHANNEL_HEIGHT = 22;\nexport const CHANNEL_BANNER_HEIGHT = 30;\nexport const CHANNEL_BANNER_WIDTH = 500;\nconst initialValue = {\n  options: {\n    slices: 5,\n    yOffset: 0,\n    ignoreSpacing: false\n  },\n  results: [],\n  inputFile: {\n    data: null,\n    height: 30,\n    width: 100\n  },\n  exportStatus: {\n    start: null,\n    end: null,\n    delta: null\n  }\n};\nexport const ImageManipulationContext = /*#__PURE__*/React.createContext(initialValue);\n\nfunction getCanvasAdnImageWithImage(image, channelHeight) {\n  const canvas = document.createElement('canvas');\n  canvas.width = CHANNEL_BANNER_WIDTH;\n  canvas.height = channelHeight;\n  const img = new Image();\n  img.src = image; // TODO: This should probably be asynchronous\n\n  return [canvas, img];\n}\n\nfunction getClippedRegion(canvas, img, x, y, width, height, channelHeight) {\n  const ctx = canvas.getContext('2d');\n  ctx.drawImage(img, x, y, width, height, 0, 0, CHANNEL_BANNER_WIDTH, channelHeight);\n  return canvas.toDataURL();\n}\n\nexport const getSlicesCount = (width, height, channelHeight) => {\n  const sizeRatio = width / CHANNEL_BANNER_WIDTH;\n  return ~~(height / (channelHeight * sizeRatio));\n};\n\nconst generateImages = (inputFile, options, cb) => {\n  const channelHeight = options.ignoreSpacing ? CHANNEL_HEIGHT : CHANNEL_BANNER_HEIGHT;\n  const sizeRatio = inputFile.width / CHANNEL_BANNER_WIDTH;\n  const slicesCount = getSlicesCount(inputFile.width, inputFile.height, channelHeight);\n  const [canvas, image] = getCanvasAdnImageWithImage(inputFile.data, channelHeight);\n  const result = [];\n\n  for (let i = 0; i < options.slices; i++) {\n    result.push(getClippedRegion(canvas, image, 0, options.yOffset + i * (channelHeight * sizeRatio), inputFile.width, inputFile.height / slicesCount, channelHeight));\n  }\n\n  cb(result);\n};\n\nconst THROTTLE_TIME = 100;\nconst debouncedGenerateImage = throttle(generateImages, THROTTLE_TIME);\n\nconst ImageManipulation = ({\n  children\n}) => {\n  const {\n    0: results,\n    1: setResults\n  } = useState(initialValue.results);\n  const {\n    0: options,\n    1: setOptions\n  } = useState(initialValue.options);\n  const {\n    0: inputFile,\n    1: setInputFile\n  } = useState(initialValue.inputFile);\n  const {\n    0: exportStatus,\n    1: setExportStatus\n  } = useState(initialValue.exportStatus);\n  useEffect(() => {\n    if (inputFile.data == null) return;\n    const start = Date.now();\n    setExportStatus(c => _objectSpread(_objectSpread({}, c), {}, {\n      start: start,\n      end: null\n    }));\n    debouncedGenerateImage(inputFile, options, results => {\n      setResults(results);\n      const end = Date.now();\n      setExportStatus(c => _objectSpread(_objectSpread({}, c), {}, {\n        end: end,\n        delta: end - start\n      }));\n    });\n  }, [inputFile, options]);\n  useEffect(() => {\n    const slices = getSlicesCount(inputFile.width, inputFile.height, options.ignoreSpacing ? CHANNEL_HEIGHT : CHANNEL_BANNER_HEIGHT);\n    setOptions(o => _objectSpread(_objectSpread({}, o), {}, {\n      slices,\n      yOffset: 0\n    }));\n  }, [inputFile]);\n  const value = {\n    results,\n    options,\n    setOptions,\n    inputFile,\n    setInputFile,\n    exportStatus,\n    setExportStatus\n  };\n  return /*#__PURE__*/_jsx(ImageManipulationContext.Provider, {\n    value: value,\n    children: children\n  });\n};\n\nexport default ImageManipulation;","map":null,"metadata":{},"sourceType":"module"}